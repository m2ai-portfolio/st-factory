# Snow-Town Decision Log

## 2026-02-07: JSONL as source of truth, SQLite as query layer
**Context:** Need persistent storage for the three contract types flowing between layers.
**Decision:** JSONL files are append-only source of truth (git-tracked). SQLite provides indexed queries but is rebuildable from JSONL at any time.
**Rationale:** JSONL is human-readable, diffable, and naturally append-only. SQLite adds query flexibility without being the authoritative store. If SQLite corrupts, rebuild from JSONL.
**Trade-offs:** Slightly slower reads (parse JSON per line) vs. simplicity and auditability.

## 2026-02-07: Contracts defined in snow-town, imported via sys.path
**Context:** Three projects (UM, SL, Academy) need access to the same contract definitions.
**Decision:** Contracts live in `snow-town/contracts/` and are imported by other projects via `sys.path.insert(0, snow_town_path)`.
**Rationale:** Avoids publishing a package to PyPI or maintaining a private registry. All projects run on the same EC2 instance. Simple path import works reliably.
**Trade-offs:** Not distributable as a standalone package. Fine for single-machine deployment.

## 2026-02-07: Persona patches default to "proposed" status
**Context:** persona_upgrader.py generates patches from recommendations, but applying them blindly could break personas.
**Decision:** All patches default to `status="proposed"`. Human review required. `--auto-apply` flag available for low-risk changes.
**Rationale:** Personas are critical to system quality. Automated generation is fine, but automated application needs explicit opt-in.

## 2026-02-07: Weekly loop cadence via cron
**Context:** How often should the feedback loop run?
**Decision:** Weekly, matching Sky-Lynx's existing Sunday 2AM cron schedule.
**Rationale:** Usage data accumulates over a week. More frequent would produce noise; less frequent would delay improvements.

## 2026-02-08: React Three Fiber over Unity for visualization
**Context:** Phase 7 needs 3D ecosystem visualization with optional VR (Quest 3).
**Decision:** Use React Three Fiber + @react-three/xr, NOT Unity.
**Rationale:** Single codebase for both browser and VR modes. Web-native (no app store). Same React skills used across the project. R3F handles both 2D dashboard embedding and WebXR immersive mode. Unity would require a separate build pipeline, C# codebase, and more complex deployment.
**Trade-offs:** R3F has lower 3D performance ceiling than Unity, but sufficient for our node/edge visualization.

## 2026-02-08: FastAPI data server separate from existing ContractStore
**Context:** Dashboard needs real-time API access to ecosystem data.
**Decision:** New FastAPI server (`api/`) reads from existing ContractStore, Academy YAML, and UM SQLite. Read-only — never writes to any data source.
**Rationale:** Decouples visualization from data mutation. Existing scripts continue to own writes. API layer just aggregates and serves. No modification to any existing code in snow-town, ultra-magnus, or academy.
**Trade-offs:** Adds a new process to run (uvicorn). But it's lightweight and can be started alongside the dashboard.

## 2026-02-08: SWR over TanStack Query for data fetching
**Context:** Dashboard needs client-side data fetching with auto-refresh.
**Decision:** SWR — simpler API, smaller bundle, built-in stale-while-revalidate.
**Rationale:** Our data fetching is straightforward (GET endpoints, 30s refresh). SWR's minimal API covers all needs without TanStack Query's overhead.

## 2026-02-13: JSONL immutability vs SQLite status tracking
**Context:** loop_status.py was reading from JSONL `read_*()` methods, which never reflect status changes (applied, rejected). Patches showed as "proposed" forever in status reports.
**Decision:** Switch all status-aware reporting to `query_*()` methods (SQLite). Overlay current SQLite status onto deserialized objects since `raw_json` retains write-time status.
**Rationale:** JSONL is the immutable event log — it records what was proposed at the time. SQLite tracks mutable state (pending → applied → rejected). Status reports must use the mutable layer.
**Trade-offs:** Slight complexity in query methods (status overlay). But correctly separates concerns: JSONL = history, SQLite = current state.

## 2026-02-13: rebuild_sqlite() must not re-append to JSONL
**Context:** `rebuild_sqlite()` was calling `write_outcome()` etc., which both insert to SQLite AND append to JSONL. Running rebuild doubled all JSONL records.
**Decision:** Extract SQLite-only insert helpers (`_insert_outcome_sqlite()` etc.). `rebuild_sqlite()` uses these. Also drops and recreates tables (handles schema changes).
**Rationale:** Rebuild is a recovery operation on the query layer — it must never touch the source of truth (JSONL).

## 2026-02-13: Manual verification recommendation for loop testing
**Context:** No organic persona-targeted recommendations existed (all 4 were pipeline/claude_md). Couldn't prove the full loop without persona data.
**Decision:** Created a manual recommendation (`sl-manual-verify-01`) targeting sky-lynx to exercise the persona_upgrader → review_patch → reject path.
**Rationale:** Can't wait weeks for organic data. The manual recommendation is clearly tagged and traceable. Verifies the complete feedback cycle works before the next cron run.

## 2026-02-13: Remove conflicting sky-lynx cron
**Context:** Both `/etc/cron.d/sky-lynx` and `/etc/cron.d/snow-town` fired Sunday 2AM. Snow-town's `run_loop.sh` already calls Sky-Lynx as step 1.
**Decision:** Delete `/etc/cron.d/sky-lynx`. Only snow-town cron remains.
**Rationale:** Dual cron caused duplicate recommendation writes (same session_id, doubled data). Single cron with dedup guard is the correct approach.

## 2026-02-13: A2A protocol for multi-agent ecosystem (roadmap)
**Context:** Chad (OpenClaw) runs its own reasoning loop on a different model. Needs to communicate with Snow Town agents as a peer, not as a tool consumer.
**Decision:** Add A2A protocol integration to roadmap (Phase 9). Defer implementation until the feedback loop is stable and Chad's reasoning loop is mature.
**Rationale:** MCP assumes single orchestrator calling tools — doesn't fit peer-to-peer agent coordination. A2A is model-agnostic and framework-agnostic, designed for exactly this use case. However, current priority is proving the ST loop works end-to-end autonomously before adding inter-agent communication.
**Trade-offs:** Adds HTTP server complexity and a new protocol layer. Worth it when we have genuinely autonomous agents that need to discover and delegate to each other.

## 2026-02-08: Next.js dev server over static export
**Context:** Dashboard uses dynamic routes (/nodes/[nodeId], /agents/[agentId]).
**Decision:** Run via `next dev` or `next start` during development. Static export deferred.
**Rationale:** Dynamic routes require either generateStaticParams or server-side rendering. For an internal dashboard on EC2, running a dev server is simpler. Static export can be re-enabled later with proper params generation.
